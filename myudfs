{"name":"anil","id":1,"course":"spark","year":2016,"date":"2017-02-10"}
{"name":"anvith","id":5,"course":"hadoop","year":2015,"date":"2017-10-26"}
{"name":"dev","id":6,"course":"hadoop","year":2015,"date":"2017-10-10"}
{"name":"raj","id":3,"course":"spark","year":2016,"date":"10-10-2015"}
{"name":"sunil","id":4,"course":"hadoop","year":2015,"date":"10/10/2016"}
{"name":"venkat","id":2,"course":"spark","year":2016,"date":"2017/10/10"}


=================================================================================================

import org.apache.spark.sql.SQLContext
import org.apache.spark.SparkConf
import org.apache.spark.SparkContext
import java.text.SimpleDateFormat
import java.util.Date
import java.text.ParseException

object SqlUtils {
  
  val dateUDF=(inputDate:String,format:String)=>{
    
    var returnDate=getRequiredDate(inputDate,format);
    
     returnDate;
  }

  
  def main(args: Array[String]): Unit = {

    val conf: SparkConf = new SparkConf().setAppName("Spark SQL with Student.json Data UDF ").setMaster("local[*]")
    val sc: SparkContext = new SparkContext(conf)
    val sqlContext: SQLContext = new org.apache.spark.sql.SQLContext(sc)

    val df = sqlContext.read.json("file:///home/hadoop/Desktop/data/input/student.json")

    
/*    df.printSchema();
    df.show(10);
*/    df.registerTempTable("web")
    sqlContext.udf.register("dateUDF", dateUDF);

    
     val query1=sqlContext.sql("select dateUDF(date,'yyyy-MM-dd') from web");
      query1.printSchema();
      query1.show(10);
  }
  
  def main1(args: Array[String]): Unit = {
    
    println(getSourceDateFormat("2017-10-10"));
  }
  
   def getSourceDateFormat(inputdate: String): String = {
    
    if (inputdate.matches("\\d{4}-\\d{2}-\\d{2}")) {
      return "yyyy-MM-dd";
    }
     if (inputdate.matches("\\d{4}-\\w{3}-\\d{2}")) {
      return "yyyy-MMM-dd";
    }
    if (inputdate.matches("\\d{2}-\\d{2}-\\d{4}")) {
      return "MM-dd-yyyy";
    }
    if (inputdate.matches("\\d{2}/\\d{2}/\\d{4}")) {
      return "MM/dd/yyyy";
    }
    if (inputdate.matches("\\d{4}/\\d{2}/\\d{2}")) {
      return "yyyy/MM/dd" ;
    }
    "wrongformat"
  }
  
   def convertUdf(inputdate: String,inputdateFormat: String, requiredDateFormat: String): String = {
     
    val parser: SimpleDateFormat = new SimpleDateFormat(inputdateFormat)
    
    val date: Date = parser.parse(inputdate)
    
    val formatter: SimpleDateFormat = new SimpleDateFormat(requiredDateFormat)
    
    val formattedDate: String = formatter.format(date)
    
    formattedDate
    
  }
  
   def getRequiredDate(inputDate: String,requiredFormar: String): String = {
    
     val sourcedateformat: String = getSourceDateFormat(inputDate)
    
    println("sourcedate format-->" + sourcedateformat)
    
    try {
      val requireddate: String =
        convertUdf(inputDate, sourcedateformat, requiredFormar)
      println("required date--->" + requireddate)
      requireddate
    } catch {
      case e: ParseException => {
        e.printStackTrace()
        return   "null"
      }

    }
  }
  
}
